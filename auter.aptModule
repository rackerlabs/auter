#!/bin/bash
# This is a script that is intended to only be called by /usr/bin/auter and
# contains linux package manager specific code for auter.

# This is the apt-get version of this script intended for Ubuntu/Debian

# Exit if this script is executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  echo "ERROR: This script is used by auter and should not be executed directly. Exiting"
fi

function check_package_manager_lock() {
  # Set default values if the variables are undefined
  [[ ${PACKAGEMANAGERLOCKRETRIES} ]] || PACKAGEMANAGERLOCKRETRIES=5
  [[ ${PACKAGEMANAGERLOCKWAITTIME} ]] || PACKAGEMANAGERLOCKWAITTIME=60

  # This is a place holder function pending code for a check for apt-get locks
}

function prepare_updates() {
  # Run any pre-prep scripts
  for SCRIPT in "${PREPREPSCRIPTDIR}"/*; do
    run_script "${SCRIPT}" "Pre-Prep"
  done

  if [[ "${PREDOWNLOADUPDATES}" == "yes" ]]; then
    if [[ $(man "${PACKAGE_MANAGER}" | grep -c download-only) -gt 0 ]]; then
      ${PACKAGE_MANAGER} update &>/dev/null
      # Check if there are any errors when checking for updates
      local ERROR_COUNT
      local AVAILABLE_PACKAGE_COUNT
      ERROR_COUNT=$("${PACKAGE_MANAGER}" -u upgrade --assume-no "${PACKAGEMANAGEROPTIONS[@]}" | grep -c '^[WE]:')
      AVAILABLE_PACKAGE_COUNT=$("${PACKAGE_MANAGER}" -u upgrade --assume-no "${PACKAGEMANAGEROPTIONS[@]}" | awk '/upgraded,.*newly installed,/ {sum=$1+$3} END {print sum}')

      if [[ ${ERROR_COUNT} -eq 0 ]]; then
        # If there are packages to be installed then download them.
        if [[ "${AVAILABLE_PACKAGE_COUNT}" -gt 0 ]]; then
          SLEEP_DELAY=$((RANDOM % MAXDELAY))
          [[ ${SLEEP_DELAY} -gt 1 ]] && logit "INFO: Sleeping for ${SLEEP_DELAY} seconds"
          sleep ${SLEEP_DELAY}
          if [[ "${ONLYINSTALLFROMPREP}" == "yes" ]]; then
            [[ -d "${DOWNLOADDIR}/${CONFIGSET}" ]] || mkdir -p "${DOWNLOADDIR}/${CONFIGSET}"
            DOWNLOADOPTION=("-o" "dir::cache::archives=${DOWNLOADDIR}/${CONFIGSET}")
            rm -f "${DOWNLOADDIR}"/"${CONFIGSET}"/*.deb
            DOWNLOADLOGMSG=" to ${DOWNLOADDIR}/${CONFIGSET}"
          fi
          declare -x DEBIAN_FRONTEND=noninteractive
          PREPOUTPUT=$("${PACKAGE_MANAGER}" "${PACKAGEMANAGEROPTIONS[@]}" "${DOWNLOADOPTION[@]}" --download-only dist-upgrade -y 2>&1)
          if [[ $(echo "${PREPOUTPUT}" | grep -c '^[WE]:') -gt 0 ]]; then
            logit "ERROR: There were errors returned by \`${PACKAGE_MANAGER} ${PACKAGEMANAGEROPTIONS[*]} ${DOWNLOADOPTION[*]} --download-only dist-upgrade -y\`. Exiting."
          else
            logit "INFO: Updates downloaded${DOWNLOADLOGMSG}"
          fi
        else [[ "${AVAILABLE_PACKAGE_COUNT}" -eq 0 ]]
          logit "INFO: No updates are available to be downloaded."
        fi
      else
        logit "ERROR: There were errors returned by \`${PACKAGE_MANAGER} -u upgrade --assume-no ${PACKAGEMANAGEROPTIONS[*]}\`. Exiting."
      fi
    else
      logit "WARNING: downloadonly option is not available"
    fi
  else
    PREPOUTPUT=$("${PACKAGE_MANAGER}" "${PACKAGEMANAGEROPTIONS[@]}" -s dist-upgrade 2>&1)
  fi
  rotate_file "${DATADIR}/last-prep-output-${CONFIGSET}"
  [[ "${PREPOUTPUT}" ]] && echo "${PREPOUTPUT}" > "${DATADIR}/last-prep-output-${CONFIGSET}"

  # Run any post-prep scripts
  for SCRIPT in "${POSTPREPSCRIPTDIR}"/*; do
    run_script "${SCRIPT}" "Post-Prep"
  done

}

function apply_updates() {
  # Prevent dialog box as we are not running the update in interactive mode
  declare -x DEBIAN_FRONTEND=noninteractive

  # Set the list of debs to be installed
  if [[ "${ONLYINSTALLFROMPREP}" == "yes" ]]; then
    local AVAILABLE_PACKAGES
    local AVAILABLE_PACKAGE_COUNT
    local ERROR_COUNT
    if [[ $(find "${DOWNLOADDIR}/${CONFIGSET}" -name "*.deb" | wc -l) -gt 0 ]]; then
      AVAILABLE_PACKAGES=$("${PACKAGE_MANAGER}" -u --just-print install --assume-no "${PACKAGEMANAGEROPTIONS[@]}" "${DOWNLOADDIR}/${CONFIGSET}"/*.deb 2>&1)
      echo "${AVAILABLE_PACKAGES}" >"${DATADIR}/last-apply-output-${CONFIGSET}"
      AVAILABLE_PACKAGE_COUNT=$(echo "${AVAILABLE_PACKAGES}" | awk '/upgraded,.*newly installed,/ {sum=$1+$3} END {print sum}')
      DEBS=("${DOWNLOADDIR}/${CONFIGSET}/"*.deb)
    else
      AVAILABLE_PACKAGE_COUNT=0
    fi

    # When passing DEBs to apt-get, the update verb won't install any that aren't already
    # installed (i.e. dependencies of other packages). Instead we need to use install.
    UPDATEACTION="install"
  else
    AVAILABLE_PACKAGES=$(${PACKAGE_MANAGER} -u upgrade --assume-no "${PACKAGEMANAGEROPTIONS[@]}" 2>&1)
    echo "${AVAILABLE_PACKAGES}" >"${DATADIR}/last-apply-output-${CONFIGSET}"
    ERROR_COUNT=$(echo "${AVAILABLE_PACKAGES}" | grep -c '^[WE]:')
    AVAILABLE_PACKAGE_COUNT=$(echo "${AVAILABLE_PACKAGES}" | awk '/upgraded,.*newly installed,/ {sum=$1+$3} END {print sum}')
    UPDATEACTION="upgrade"
  fi

  if [[ ${ERROR_COUNT} -eq 0 ]]; then
    if [[ "${AVAILABLE_PACKAGE_COUNT}" -gt 0 ]]; then
      local PACKAGES_BEFORE
      local PACKAGES_AFTER
      for SCRIPT in "${PREAPPLYSCRIPTDIR}"/*; do
        run_script "${SCRIPT}" "Pre-Apply"
      done

      SLEEP_DELAY=$((RANDOM % MAXDELAY))
      [[ ${SLEEP_DELAY} -gt 1 ]] && logit "INFO: Sleeping for ${SLEEP_DELAY} seconds"
      sleep ${SLEEP_DELAY}
      logit "INFO: Applying updates"
      PACKAGES_BEFORE=$(dpkg --list)

      # We don't want to allow the user to interrupt a yum/dnf/apt transaction or Bad Things Happen.
      echo "Trying to update"
      trap '' SIGINT SIGTERM
      RUN_OUTPUT=$("${PACKAGE_MANAGER}" "${UPDATEACTION}" "${PACKAGEMANAGEROPTIONS[@]}" -y "${DEBS[@]}")
      rotate_file "${DATADIR}/last-apply-output-${CONFIGSET}"
      echo "${RUN_OUTPUT}" &>"${DATADIR}/last-apply-output-${CONFIGSET}"
      default_signal_handling

      PACKAGES_AFTER=$(dpkg --list)

      if [[ "${PACKAGES_BEFORE}" == "${PACKAGES_AFTER}" ]]; then
        logit "WARNING: No updates were applied. $(echo "${RUN_OUTPUT}" | grep 'upgraded,.*installed,')"
        quit 3
      fi

      logit "INFO: Updates complete. You may need to reboot for some updates to take effect"
      log_last_run

      for SCRIPT in "${POSTAPPLYSCRIPTDIR}"/*; do
        run_script "${SCRIPT}" "Post-Apply"
      done

      # Excluding this check because the REBOOTCALL variable is used by the main auter script
      # shellcheck disable=SC2034
      [[ "${AUTOREBOOT}" == "yes" ]] && REBOOTCALL=1

    else
      logit "INFO: No updates are available to be applied."
      log_last_run
    fi
  else
    logit "ERROR: Exit status ${RC} returned by \`${PACKAGE_MANAGER} -u upgrade --assume-no ${PACKAGEMANAGEROPTIONS[*]}\`. Exiting."
    quit 3
  fi
}
