#!/bin/bash
# This is a script that is intended to only be called by /usr/bin/auter and
# contains linux package manager specific code for auter.

# This is the apt-get version of this script intended for Ubuntu/Debian

# Exit if this script is executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  echo "ERROR: This script is used by auter and should not be executed directly. Exiting"
fi

function check_package_manager_lock() {
  # Set default values if the variables are undefined
  [[ ${PACKAGEMANAGERLOCKRETRIES} ]] || PACKAGEMANAGERLOCKRETRIES=5
  [[ ${PACKAGEMANAGERLOCKWAITTIME} ]] || PACKAGEMANAGERLOCKWAITTIME=60

  # This is a place holder function pending code for a check for apt-get locks
}

function prepare_updates() {
  # Run any pre-prep scripts
  for SCRIPT in "${PREPREPSCRIPTDIR}"/*; do
    run_script "${SCRIPT}" "Pre-Prep"
  done

  PREPOUTPUT="$(date '+%F %T')\\n"
  if [[ "${PREDOWNLOADUPDATES}" == "yes" ]]; then
    if [[ $(man "${PACKAGE_MANAGER}" | grep -c download-only) -gt 0 ]]; then
      ${PACKAGE_MANAGER} update &>/dev/null
      # Check if there are any errors when checking for updates
      local ERROR_COUNT
      local AVAILABLE_PACKAGE_COUNT


      ERROR_COUNT=$("${PACKAGE_MANAGER}" -u upgrade --assume-no "${PACKAGEMANAGEROPTIONS[@]}" | grep -c '^[WE]:')
      AVAILABLE_PACKAGE_COUNT=$("${PACKAGE_MANAGER}" -u upgrade --assume-no "${PACKAGEMANAGEROPTIONS[@]}" | awk '/upgraded,.*newly installed,/ {sum=$1+$3} END {print sum}')

      if [[ ${ERROR_COUNT} -eq 0 ]]; then
        # If there are packages to be installed then download them.
        if [[ "${AVAILABLE_PACKAGE_COUNT}" -gt 0 ]]; then
          SLEEP_DELAY=$((RANDOM % MAXDELAY))
          [[ ${SLEEP_DELAY} -gt 1 ]] && logit "INFO: Sleeping for ${SLEEP_DELAY} seconds"
          sleep ${SLEEP_DELAY}
          if [[ "${ONLYINSTALLFROMPREP}" == "yes" ]]; then
            [[ -d "${DOWNLOADDIR}/${CONFIGSET}" ]] || mkdir -p "${DOWNLOADDIR}/${CONFIGSET}"
            DOWNLOADOPTION=("-o" "dir::cache::archives=${DOWNLOADDIR}/${CONFIGSET}")
            rm -f "${DOWNLOADDIR}"/"${CONFIGSET}"/*.deb
            DOWNLOADLOGMSG=" to ${DOWNLOADDIR}/${CONFIGSET}"
          fi
          declare -x DEBIAN_FRONTEND=noninteractive
          PREPOUTPUT=$("${PACKAGE_MANAGER}" "${PACKAGEMANAGEROPTIONS[@]}" "${DOWNLOADOPTION[@]}" --download-only dist-upgrade -y 2>&1)
          if [[ $(echo "${PREPOUTPUT}" | grep -c '^[WE]:') -gt 0 ]]; then
            logit "ERROR: There were errors returned by \`${PACKAGE_MANAGER} ${PACKAGEMANAGEROPTIONS[*]} ${DOWNLOADOPTION[*]} --download-only dist-upgrade -y\`. Exiting."
            PREPOUTPUT+="\\nSTATUS:FAILED:Errors returned by package manager"
          else
            logit "INFO: Updates downloaded${DOWNLOADLOGMSG}"
            PREPOUTPUT+="\\nSTATUS:SUCCESS:Package download complete"
          fi
        else [[ "${AVAILABLE_PACKAGE_COUNT}" -eq 0 ]]
          logit "INFO: No updates are available to be downloaded."
          PREPOUTPUT+="STATUS:SUCCESS:No updates available"
        fi
      else
        logit "ERROR: There were errors returned by \`${PACKAGE_MANAGER} -u upgrade --assume-no ${PACKAGEMANAGEROPTIONS[*]}\`. Exiting."
        PREPOUTPUT+="\\nSTATUS:FAILED:Errors returned by package manager"
      fi
    else
      if [[ "${ONLYINSTALLFROMPREP}" == "yes" ]]; then
        logit "ERROR: DOWNLOADOPTION set to 'yes' but the '--downloadonly' option is not available in the current version of ${PACKAGE_MANAGER}"
        quit 3
      else
        logit "WARNING: downloadonly option is not available"
      PREPOUTPUT+="\\nSTATUS:Download only not available"
      fi
    fi
  else
    PREPOUTPUT+=$("${PACKAGE_MANAGER}" "${PACKAGEMANAGEROPTIONS[@]}" -s dist-upgrade 2>&1)
  fi
  rotate_file "${DATADIR}/last-prep-output-${CONFIGSET}"
  [[ "${PREPOUTPUT}" ]] && echo -e "${PREPOUTPUT}" > "${DATADIR}/last-prep-output-${CONFIGSET}"

  # Run any post-prep scripts
  for SCRIPT in "${POSTPREPSCRIPTDIR}"/*; do
    run_script "${SCRIPT}" "Post-Prep"
  done

}

function apply_updates() {
  # Prevent dialog box as we are not running the update in interactive mode
  declare -x DEBIAN_FRONTEND=noninteractive

  APPLYOUTPUT="$(date '+%F %T')\\n"
  # Set the list of debs to be installed
  if [[ "${ONLYINSTALLFROMPREP}" == "yes" ]]; then
    local AVAILABLE_PACKAGES
    local AVAILABLE_PACKAGE_COUNT
    local ERROR_COUNT
    if [[ $(find "${DOWNLOADDIR}/${CONFIGSET}" -name "*.deb" | wc -l) -gt 0 ]]; then
      AVAILABLE_PACKAGES=$("${PACKAGE_MANAGER}" -u --just-print install --assume-no "${PACKAGEMANAGEROPTIONS[@]}" "${DOWNLOADDIR}/${CONFIGSET}"/*.deb 2>&1)
      echo "${AVAILABLE_PACKAGES}" >"${DATADIR}/last-apply-output-${CONFIGSET}"
      AVAILABLE_PACKAGE_COUNT=$(echo "${AVAILABLE_PACKAGES}" | awk '/upgraded,.*newly installed,/ {sum=$1+$3} END {print sum}')
      DEBS=("${DOWNLOADDIR}/${CONFIGSET}/"*.deb)
    else
      AVAILABLE_PACKAGE_COUNT=0
    fi

    # When passing DEBs to apt-get, the update verb won't install any that aren't already
    # installed (i.e. dependencies of other packages). Instead we need to use install.
    UPDATEACTION="install"
  else
    AVAILABLE_PACKAGES=$(${PACKAGE_MANAGER} -u upgrade --assume-no "${PACKAGEMANAGEROPTIONS[@]}" 2>&1)
    echo "${AVAILABLE_PACKAGES}" >"${DATADIR}/last-apply-output-${CONFIGSET}"
    ERROR_COUNT=$(echo "${AVAILABLE_PACKAGES}" | grep -c '^[WE]:')
    AVAILABLE_PACKAGE_COUNT=$(echo "${AVAILABLE_PACKAGES}" | awk '/upgraded,.*newly installed,/ {sum=$1+$3} END {print sum}')
    UPDATEACTION="upgrade"
  fi

  if [[ ${ERROR_COUNT} -eq 0 ]]; then
    if [[ "${AVAILABLE_PACKAGE_COUNT}" -gt 0 ]]; then
      local PACKAGES_BEFORE
      local PACKAGES_AFTER

      # Sleep before running pre-scripts and updates
      SLEEP_DELAY=$((RANDOM % MAXDELAY))
      [[ ${SLEEP_DELAY} -gt 1 ]] && logit "INFO: Sleeping for ${SLEEP_DELAY} seconds"
      sleep ${SLEEP_DELAY}

      for SCRIPT in "${PREAPPLYSCRIPTDIR}"/*; do
        run_script "${SCRIPT}" "Pre-Apply"
      done

      logit "INFO: Applying updates"
      PACKAGES_BEFORE=$(dpkg --list)

      # We don't want to allow the user to interrupt a yum/dnf/apt transaction or Bad Things Happen.
      echo "Trying to update"
      trap '' SIGINT SIGTERM
      if APPLYOUTPUT=$("${PACKAGE_MANAGER}" "${UPDATEACTION}" "${PACKAGEMANAGEROPTIONS[@]}" -y "${DEBS[@]}" 2>&1); then
        APPLYOUTPUT+="\\nSTATUS:SUCCESS:Package updates applied"
      else
        APPLYOUTPUT+="\\nSTATUS:FAILED:Package updates failed"
      fi
      rotate_file "${DATADIR}/last-apply-output-${CONFIGSET}"
      echo -e "${APPLYOUTPUT}" &>"${DATADIR}/last-apply-output-${CONFIGSET}"
      default_signal_handling

      PACKAGES_AFTER=$(dpkg --list)

      if [[ "${PACKAGES_BEFORE}" == "${PACKAGES_AFTER}" ]]; then
        logit "WARNING: No updates were applied. $(echo "${APPLYOUTPUT}" | grep 'upgraded,.*installed,')"
        quit 3
      fi

      logit "INFO: Updates complete. You may need to reboot for some updates to take effect"
      log_last_run

      for SCRIPT in "${POSTAPPLYSCRIPTDIR}"/*; do
        run_script "${SCRIPT}" "Post-Apply"
      done

      # Excluding this check because the REBOOTCALL variable is used by the main auter script
      # shellcheck disable=SC2034
      [[ "${AUTOREBOOT}" == "yes" ]] && REBOOTCALL=1

    else
      logit "INFO: No updates are available to be applied."
      APPLYOUTPUT+="\\nSTATUS:SUCCESS:No updates available"
      echo -e "$APPLYOUTPUT" > "${DATADIR}/last-apply-output-${CONFIGSET}"
      log_last_run
    fi
  else
    logit "ERROR: Exit status ${RC} returned by \`${PACKAGE_MANAGER} -u upgrade --assume-no ${PACKAGEMANAGEROPTIONS[*]}\`. Exiting."
    APPLYOUTPUT+="\\nSTATUS:FAILED:Updates failed with status $RC"
    echo -e "$APPLYOUTPUT" > "${DATADIR}/last-apply-output-${CONFIGSET}"
    quit 3
  fi
}
